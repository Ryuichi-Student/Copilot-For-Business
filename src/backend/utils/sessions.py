import time
import uuid
from collections import deque
from typing import Any, Dict, List, Optional, Iterable
from src.backend.utils.gpt import get_gpt_response


# TODO: Load from and save to persistent storage
class Session_Storage:
    """
        A class for managing sessions with a focus on maintaining a most-recently-used (MRU) order.

        Attributes:
            session_data (dict): Stores session information indexed by session ID.
            mru (deque): A double-ended queue to track session IDs in MRU order.
    """

    def __init__(self, rerun):
        self.session_data = {}
        self.mru: deque = deque()
        self.rerun = rerun

    def create_session(self, session_name, rerun=True, autogenerate=True):
        """
        Creates a new session with the given name, stores it, and tracks it as the most recently used session.

        Args:
            rerun:
            session_name (str): The name of the session to create.
        """
        session_id = uuid.uuid4()
        self.session_data[session_id] = {"name": session_name, "data": None, "autogenerate": autogenerate}
        self.mru.appendleft(session_id)  # Directly add to the front for MRU
        if rerun:
            self.rerun()

    def delete_session(self, session_id):
        """
        Marks a session for deletion and triggers a UI rerun. Actual deletion from the MRU tracking is deferred.

        Args:
            session_id (UUID): The unique identifier of the session to delete.

        Returns:
            bool: False if the session couldn't be deleted (session not found).
        """
        if session_id in self.session_data:
            del self.session_data[session_id]
            try:
                self.mru.remove(session_id)  # Direct removal from MRU
            except ValueError:
                pass  # In case session_id is not in MRU, which shouldn't happen but just in case
            self.rerun()
            return True
        return False

    def get_sessions(self) -> List[uuid.UUID]:
        """
        Cleans up the MRU list by removing any sessions marked for deletion and returns the current MRU list.

        Returns:
            list: A list of session IDs in most-recently-used order.
        """
        return list(self.mru)

    def get_session_data(self, session_id: uuid.UUID) -> Optional[Dict[str, Any]]:
        """
        Retrieves the data for a given session.

        Args:
            session_id (UUID): The unique identifier of the session.

        Returns:
            Optional[dict]: The data associated with the session.
        """
        return self.session_data.get(session_id)

    def update_session_data(self, session_id: uuid.UUID, data: Any = None) -> None:
        """
        Updates the data for a given session and ensures the session is marked as most recently used.

        Args:
            session_id (UUID): The unique identifier of the session to update.
            data: The new data to store in the session.
        """
        if session_id in self.session_data and data is not None:
            self.session_data[session_id]["data"] = data
            self.use_session(session_id)  # Ensures MRU is updated correctly
            self.rerun()

    def update_session_name(self, session_id: str, query: str) -> Iterable[str]:
        """
        Uses the query to generate a name for the session and updates the session with the new name. Returns an iterable for streaming.

        Args:
            session_id (str): The unique identifier of the session to update.
            query (str): The query to use for generating the session name.
        """
        name = get_gpt_response(("user", f"""I want to generate a name for a GPT session, based on the user's query. Write down a short name (and nothing else) that describes and summarises the query: "{query}"."""))
        print(f"Named autogenerated session as {name}")
        self.session_data[session_id]["name"] = name
        x = ""
        for letter in name:
            x += letter
            yield f"Generating session name: {x} "
            time.sleep(0.1)
        yield f"Generated session: {x} "
        time.sleep(0.4)

    def update_config(self, session_id: str, config: Dict[str, Any], overwrite=True, rerun=False) -> None:
        if session_id in self.session_data:
            if overwrite:
                self.session_data[session_id].update(config)
            else:
                for key, value in config.items():
                    self.session_data[session_id].setdefault(key, value)
        if rerun:
            self.rerun()

    def get_config(self, session_id: uuid.UUID, config_name) -> Optional[Any]:
        return self.session_data.get(session_id, {}).get(config_name)

    def use_session(self, session_id: str) -> None:
        if session_id in self.session_data:
            self.mru.remove(session_id)
        self.mru.appendleft(session_id)

    @property
    def requires_autogenerated_session(self) -> bool:
        return all(not session.get("autogenerate", False) for session in self.session_data.values())
